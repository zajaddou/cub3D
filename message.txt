```c
void	init_hor(t_mlx *mlx, double ray_angle, int i, t_Raycasting *r)
{
	r->wallhorhitx = 0;
	r->wallhorhity = 0;
	r->hordistance = 1e30;
	r->foundHorWall = false;
	r->Ay = floor(mlx->player.y * TILE / TILE) * TILE;
	if (mlx->rays[i].isRayFacingDown)
		r->Ay += TILE;
	r->Ax = mlx->player.x * TILE
		+ ((r->Ay - mlx->player.y * TILE) / tan(ray_angle));
	r->ystep = TILE;
	if (mlx->rays[i].isRayFacingUp)
		r->ystep *= -1;
	r->xstep = TILE / tan(ray_angle);
	if (mlx->rays[i].isRayFacingLeft && r->xstep > 0)
		r->xstep *= -1;
	if (mlx->rays[i].isRayFacingRight && r->xstep < 0)
		r->xstep *= -1;
	r->nextHorTouchX = r->Ax;
	r->nextHorTouchY = r->Ay;
	if (mlx->rays[i].isRayFacingUp)
		r->nextHorTouchY -= 0.01;
}

void	cast_hor(t_mlx *mlx, double ray_angle, int i, t_Raycasting *r)
{
	init_hor(mlx, ray_angle, i, r);
	while (r->nextHorTouchX >= 0 && r->nextHorTouchY >= 0
		&& r->nextHorTouchX < ((int)mlx->data.len * TILE)
		&& r->nextHorTouchY < ((int)mlx->data.k * TILE))
	{
		if (haswallat(mlx, r->nextHorTouchX, r->nextHorTouchY))
		{
			r->foundHorWall = true;
			r->wallhorhitx = r->nextHorTouchX;
			r->wallhorhity = r->nextHorTouchY;
			r->hordistance = calc_distance(mlx->player.x * TILE,
					mlx->player.y * TILE,
					r->nextHorTouchX, r->nextHorTouchY);
			break ;
		}
		else
		{
			r->nextHorTouchX += r->xstep;
			r->nextHorTouchY += r->ystep;
		}
	}
}

void	init_ver(t_mlx *mlx, double ray_angle, int i, t_Raycasting *r)
{
	r->wallverhitx = 0;
	r->wallverhity = 0;
	r->Verdistance = 1e30;
	r->foundVerWall = false;
	r->Ax = floor(mlx->player.x * TILE / TILE) * TILE;
	if (mlx->rays[i].isRayFacingRight)
		r->Ax += TILE;
	r->Ay = mlx->player.y * TILE
		+ ((r->Ax - mlx->player.x * TILE) * tan(ray_angle));
	r->xstep = TILE;
	if (mlx->rays[i].isRayFacingLeft)
		r->xstep *= -1;
	r->ystep = TILE * tan(ray_angle);
	if (mlx->rays[i].isRayFacingUp && r->ystep > 0)
		r->ystep *= -1;
	if (mlx->rays[i].isRayFacingDown && r->ystep < 0)
		r->ystep *= -1;
	r->nextVerTouchX = r->Ax;
	r->nextVerTouchY = r->Ay;
	if (mlx->rays[i].isRayFacingLeft)
		r->nextVerTouchX -= 0.01;
}

void	cast_ver(t_mlx *mlx, double ray_angle, int i, t_Raycasting *r)
{
	init_ver(mlx, ray_angle, i, r);
	while (r->nextVerTouchX >= 0 && r->nextVerTouchY >= 0
		&& r->nextVerTouchX < ((int)mlx->data.len * TILE)
		&& r->nextVerTouchY < ((int)mlx->data.k * TILE))
	{
		if (haswallat(mlx, r->nextVerTouchX, r->nextVerTouchY))
		{
			r->foundVerWall = true;
			r->wallverhitx = r->nextVerTouchX;
			r->wallverhity = r->nextVerTouchY;
			r->Verdistance = calc_distance(mlx->player.x * TILE,
					mlx->player.y * TILE,
					r->nextVerTouchX, r->nextVerTouchY);
			break ;
		}
		else
		{
			r->nextVerTouchX += r->xstep;
			r->nextVerTouchY += r->ystep;
		}
	}
}

void	cast_ray(t_mlx *mlx, double ray_angle, int i)
{
	t_Raycasting	r;

	ray_angle = update_angle(ray_angle);
	r.foundHorWall = false;
	r.foundVerWall = false;
	cast_hor(mlx, ray_angle, i, &r);
	cast_ver(mlx, ray_angle, i, &r);
	if (r.hordistance < r.Verdistance)
	{
		mlx->rays[i].wallhitx = r.wallhorhitx;
		mlx->rays[i].wallhity = r.wallhorhity;
		mlx->rays[i].distance = r.hordistance;
		mlx->rays[i].wasHitVertical = false;
	}
	else
	{
		mlx->rays[i].wallhitx = r.wallverhitx;
		mlx->rays[i].wallhity = r.wallverhity;
		mlx->rays[i].distance = r.Verdistance;
		mlx->rays[i].wasHitVertical = true;
	}
}
```